---
title: "RNA-seq analysis and Shiny application"
author: "David GALLIEN & Gabin COUDRAY"
date: "15/04/2020"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(DESeq2)
library(Biobase)
library(gplots)
library(RColorBrewer)
library(shiny)
library(tidyverse)
library(NMF)
```

<p>&nbsp; </p> 
## Introduction
<p style="text-align:justify";>
Most of biological researchers does not have time to use the tools which allow to analyze the data generated by new technology. It is why it is imperative to offer to biologist facilitate tools that can allow them to be more efficient and conscenrate on there research.<p/>

<p style="text-align:justify";>
In our project we want to be able to generate application that can help them to explore there data and their results in R environment. For that, Shiny package allows to create interactive web applications.<p/>

<p style="text-align:justify";>
Nevertheless to create a vizualisation interactive application we need to have something to show. In medical research which is the main field we want to explore, next generation sequencing are often use and generate big data which we need to be analyzed and explored. We decided to concentrate our work on RNA sequencing (RNA-seq), this next generation sequencing had the purpose to detect differential express between cellular type of different condition.<p/>

## Objectives
### Context
<p style="text-align:justify";>
RNA-seq is a new way for sequencig RNA fastly than previous techniques like Sanger. The main aim of RNA-seq is the study of the differential expression of genes between different conditions. RNA sequencing was cited for the first time in 2008. Since, the number of publication with RNA-seq data grown exponentially. This kind of analysis uses NGS (Next-Generation Sequencing) technology like Illumina, Roche 454 or Ion torrent. 
</p>
An RNA sequencing analysis presents 3 main steps :  

 - Random fragmentation of mature RNA  
 
 - Amplification of fragments by PCR  
 
 - Sequencing of these amplified fragments making millions of reads
 
<p style="text-align:justify";>
The number of reads obtained is proportional to the abundance of RNA in the cell. These reads are stored in fastQ format files and their quality is estimated. Then each read is mapped to the genome of the organism. After the mapping we got BAM files in which every lines represent an alignment of a read. Finally, we count the number of reads by position and make a table in order to analyse this.
</p>

<p style="text-align:justify";>
Today more and more studies use RNA sequencing then there are more and more data to analyze. By following this problematic we will set up an Rshiny application allowing to analyze the RNA-seq data as deeply as possible. This application aims to answer as many questions as possible and visualize the results intuitively.
</p>

### Shiny application
<p style="text-align:justify";>
Shiny is an R package that permit to build easily dynamic and interactive web applications. An Rshiny application is separated into two parts :  

 - A User Interface (UI) which controls the appearance of the app  
 
 - A server function contains the build of the app  
</p>
<p style="text-align:justify";>
Our goal is to create an application which allows to visualize the data of an RNA-seq analysis. This application will take in input the count table obtained after the RNAseq, normalize the data and analyse it with statistical techniques. We want to display plots like MAplot, Volcano plot and others results from statistical analysis. All this to find a potential differential gene expression.
</p>
<p>&nbsp; </p> 
<p> First we will explain more deeply the RNA-seq analysis then we will proceed to the count table analysis under R thanks to the package DESeq2. Finally, we will create the Shiny app to study the results of the analysis. </p>

### RNA-sequencing data analysis
#### Step 1 : Data generation
<p style="text-align:justify";>
Firstly, to get the dataset, RNA is extraced from cells and mRNA are isolated by poly-A selection. Once extracted, mRNA are fragmented and reverse transcribed into cDNA. Then, cDNA are sequenced with adaptadors sequences using NGS technologies. The most used today is the Illumina technologie. This technologie uses clonal amplification and sequencing by synthesis (SBS). The sequencing can be "single end" (each read is independant) or "paired-end" (reads are paired). After the sequencing, millions of reads are produced.
</p>
#### Step 2 : Quality
<p style="text-align:justify";>
The sequencer gives as a result some FASTQ files. In this kind of file, a read is represented by a block of four lines. Then we can use a programm like FastQC to check the fiability of the sequencing.
</p>
#### Step 3 : Mapping
<p style="text-align:justify";>
This part of the analysis consists in aligning all the reads on the genome of the organism studied. One read is mapped to the region of the genome which is the most similar. The mean of the number of reads mapped on a region is called the depth. After the mapping, we get BAM files in which each line represent a read.
</p>
#### Step 4 : Quantification
<p style="text-align:justify";>
The number of reads is a reflection of the RNA abundance of RNA in the cell then we can estimate the expression level of the gene. That's why it is important to count the read mapped for each gene. The aim of this step is to build a count table in order to import it in R and manipulate easily.
</p>
#### Step 5 : Statistics
<p style="text-align:justify";>
We can visualize our data by a density signal on a genome browser like IGV. This allows to see the position of the exons and the level of expressions. We can also produce plot like MA-plot or Volcano plot in order to compare samples.
</p>
<p style="text-align:justify";>
To go further and see if there is a differential expression we have to normalize the data and then use differents statistical tests. We obtain adjusted p-value with which we can do a list of gene defirentially expressed.
</p>

### DESeq2
#### What is DESeq2 ?
<p style="text-align:justify";>
DESeq2 is package from R which means Differential gene expression analysis based on the negative binomial distribution. It is available on Bioconductor, a webside which provides open source software for bioinformatics and more specificly for the analysis and the study of high-throughput sequencing like RNA-seq here. With the differents tools of this packages, we can estimate some mean-variance relation in the data and test for differential expression based on a model using the negative binomial distribution. 
</p>
<p style="text-align:justify";>
The negative binomial distribution is an alternative to Poisson law. It is a discrete probability distribution. We consider an experiment which can give a success of probability p or a failure and this experiment continue until we obtain a given number of successes. The aim is to know the number of fails before the given number of successes.
</p>
<p style="text-align:justify";>
We use te negative binomial distribution because count read data is not a continuous thing so they only take non-negative integer values and we can't use a normal distribution. In the negative binomial distribution, the variance is always greater than the mean, or equal. Further, in RNA-seq, under-expressed genes have a greater variance thant overexpressed genes.
</p>

#### Dataset
<p style="text-align:justify";>
We will proceed to a differential gene expression analysis using DESeq2. To do this we have data from a study of Himes BE, Jiang X, Wagner P, et al. named RNA-Seq transcriptome profiling identifies CRISPLD2 as a glucocorticoid responsive gene that modulates cytokine function in airway smooth muscle cells. Glucocorticoid are used to treat asthma and the aim of this article is to understand the mechanism in the airway smooth muscle using RNA-seq.
</p>
<p style="text-align:justify";>
The experiment involve 8 samples, 4 treated samples with dexamethasone (synthetic glucocoricoid) and 4 control sample with no treatment. 
As a data we have a reads count table in which we can find the number of read mapped for each gene in each sample. We have also a metadata table in which we have informations for the 8 samples. And finally a gene annotation data in which we have informations about all the genes.
</p>

#### DESeq2 analysis
Firstly we import the 3 data table which we will use during this analysis. The "counts_table" contains the counting of read mapped on each genes by samples, "airway_metadata" contains the information about the samples and "anno" contains the informations about the genes. We import these data using the tidyverse package. This makes it easier to manipulate and analyze big data.
```{r Import data, message=FALSE}
counts_table <- read_csv("airway_scaledcounts.csv") 
airway_metadata <- read_csv("airway_metadata.csv")
anno <- read_csv("annotables_grch38.csv")
anno <- anno %>% select(ensgene,symbol)

# Sequencing factor
airway_metadata$format <- factor(c("single-end","single-end","single-end","single-end","single-end","single-end","single-end","single-end"))
counts_table <- as.data.frame(counts_table)
airway_metadata<- as.data.frame(airway_metadata)
```

## Create the dds object :
<p style="text-align:justify";>
This object contain the counts table and the design of the experiment name "Coldata".
In this design we have at least one variable of type factor wich is the biological condition of the experiment, here our column with condition is dex and condition are "treated" and "control"
We also have a factor wich is the type of sequenccing : "single-read" or "pair-end".  
We can also change the formul of our design later directly in our dds object. The design is used to estimate the dipersion and the log fold change of the model.
To have create dds object we need that the colname of count table and the row of design are the same and in the same order.
After we have create the dds object we need to set the reference of biological condition,by default DESeq2 set the reference of biological based on the alphabetical order so we need to set reference
</p>



```{r dds object}
# Create the dds object
dds <- DESeqDataSetFromMatrix(counts_table,colData=airway_metadata,design = ~dex,tidy = TRUE)
# Set reference of experience, here "control"
colData(dds)$dex <- relevel(colData(dds)$dex , ref="control")
# To display experiment design.
colData(dds) 
# To display column which biological condition is set.
design(dds)

```

# Explorate data 
<p style="text-align:justify";>
Now that we have our first dds object we can explore the data of our dds object.
In this part we are just going to explore the count table and discovered our crude data, we want to know how are on the whole the result of RNA-seq, so we are going to counts the number of null count for each sample, the sequencing depth and the distribution of count for each sample.
</p>

```{r Explorate data}
# the function counts() allow to output the count table of dds 
counts_dds <- counts(dds)
# Number of null count for each sample.
apply(counts_dds, 2 ,FUN = function(x) sum(x==0))
# Depth of sample.
#colSums() allow to do sum of each value of each sample that
depth <- colSums(counts_dds)
depth <- as.data.frame(depth)
depth$sample <- row.names(depth)
ggplot(depth, aes( x=sample ,y=depth))+ geom_bar(stat="identity",col="black", fill="white")+labs(title = "Depth of each sample", x="Sample", y="Depth")+theme_bw()
# Vizualisation of count ditribution
# To facilitate the vizualisation we use the log-freq of each count value "log(count+1)"
counts_dds <-as.data.frame(counts_dds)
for(i in 1:8){
 p <- ggplot(data=counts_dds, aes(log(counts_dds[,i]+1))) + geom_histogram(breaks=seq(0,14,1),col="black",fill="grey")+theme_light()+labs(title=colnames(counts_dds)[i], x="Count value (number of read by genes) in log(count+1)",y="Count frequency") + theme_bw()
}
p

```

# Filtrate data
Once our crude count table explorate, we arbitrary decide to remove row wich have few reads, that allow less memory size of dds object and improve the speed of all functions of DESeq2 in dds. Here we keep the rows that have least 5 reads total(minimum treshold of coverage).
After new dds object we do again the explorate method see above.

```{r Filtrate data}
# keep that genes with count over 5.
count_mean5 <- counts_dds[rowMeans(counts_dds)>= 5 , ]#ancienne commande 

# New dds object with genes count over 5.
dds_5 <- DESeqDataSetFromMatrix(count_mean5,colData=airway_metadata,design = ~dex)
colData(dds_5)$dex <- relevel(colData(dds_5)$dex , ref="control") #ancienne commande

# Vizualisation of count ditribution
# To facilitate the vizualisation we use the log-freq of each count value "log(count+1)"
counts_dds_5 <- counts(dds_5)
counts_dds_5 <-as.data.frame(counts_dds_5)

par(mfrow=c(1,2))
for(i in 1:8){
p <- ggplot(data=counts_dds_5, aes(log(counts_dds_5[,i]+1))) + geom_histogram(breaks=seq(0,14,1),col="black",fill="grey")+theme_light()+labs(title=colnames(counts_dds_5)[i], x="Count value (number of read by genes) in log(count+1)",y="Count frequency")+theme_bw()
  
}
p

```
# Differential analysis and normalization
Now we have our final dds object, we can use the function DESeq() on our dds object to generate the normalization and the differential analysis, DESeq() do it in one step.

DESeq2 use the method

AJOUTER EXPLICATION NORMALISATION ET ANALYSE DIFFERENTIEL PARAMETRE




```{r Differential analysis}
# Function DESeq()
dds_5 <- DESeq(dds_5)
# Verification that we have keep our design
# The scale factor resulting of normalization are stock in size factor of our design.
colData(dds_5)
# Verification of normalization 
# The scale factor resulting of normalization are stock on size factor of the result
# Depth of our count table after 
depth_normalize <- colSums(counts(dds_5, normalized= TRUE))
depth_normalize <- as.data.frame(depth_normalize)
depth_normalize$sample <- row.names(depth_normalize)
ggplot(depth_normalize, aes( x=sample ,y=depth_normalize))+ geom_bar(stat="identity",col="black", fill="white")+labs(title = "Depth of each sample", x="Sample", y="Depth")+theme_minimal()
#Now we see that the depth are approximatively equal, our data has been well normalize

# Vizualisation of count ditribution after normalization
# To facilitate the vizualisation we use the log-freq of each count value "log(count+1)"
count_normalize <- counts(dds_5, normalized= TRUE)
count_normalize <-as.data.frame(count_normalize)
par(mfrow=c(1,2))
for(i in 1:8){
p <- ggplot(data=count_normalize, aes(log(count_normalize[,i]+1))) + geom_histogram(breaks=seq(0,14,1),col="black",fill="grey")+theme_light()+labs(title=colnames(count_normalize)[i], x="Count value (number of read by genes) in log(count+1)",y="Count frequency")
  
}
p 
```
# Dispersion 
<p style="text-align:justify";>
Dispersion is a parameters of negative binomial distribution, and describe how much the variance goes away from the mean.
For each count a dispersion is calculate and we can access to this values with dispersions() function on dds object. The most common measures for dispersion are standard deviation and variance. We use it during RNA-seq analysis to testify to the variability of the data. 
</p>

```{r Dispersion}
# Dispersion plot 
dispersion <- as.data.frame(dispersions(dds_5))
ggplot(dispersion,aes(x=sqrt(dispersions(dds_5)))) + geom_boxplot() + scale_x_continuous(breaks=seq(0,4,0.5)) + theme_bw() + labs(title="Squared root of dispersion calculate by DESeq2", x= "")

# Relationship between dispersion and counts means.
# DESeq2 offer a function that can directly display a plot which describe the relation ship beetween dispersion and count mean.

DESeq2::plotDispEsts(dds_5, main= "Relationship between dispersion and counts means")
# We obtain a plot that show the final estimate which are obtain after shrunk of genes estimate and we finaly observe the fitted estimate. We can also observed outliers value.

```

# Differential expression analysis 
<p style="text-align:justify";>
After we observe the dispersion of genes we gonna really interest about our differential expression analysis results. The results table is generated by the function results() which take as parameter the dds_5 object done before. In this table we have the base mean, log2 fold changes, p-value and adjusted p-value. We have these values for each gene.
Once the results table obtained, we class the genes by increasing value and we keep only genes with a p-value lower than 0.05. It is the treshold which means that the gene is diferentialy expressed.
</p>
```{r Differetial expression analysis}
res_dif <- results(dds_5, tidy= TRUE)
res <- results(dds_5, tidy= TRUE)
summary(res_dif)
resultsNames(dds_5)
resOrdered <- res_dif[order(res_dif$pvalue),]
summary(res_dif)
# Number of genes wich is differential express at 5%
table(res_dif$padj <= 0.05, useNA="always")
# Selection of genes DE at 5%
res_Sig <- na.omit(res_dif)
res_Sig <- res_Sig[res_Sig$padj<=0.05,]
nrow(res_Sig)
```

### Plot count
<p style="text-align:justify";>
Then we do a plot count to visualize the number of 
</p>
```{r count Plot}

plotCounts(dds, gene="ENSG00000103196", intgroup="dex")
```

```{r MA plot}
# MA plot : relationship between mean count of a gene and it log2 ratio between the two conditions
# MA plot 
DESeq2::plotMA(dds_5, main = "Relationship between mean count of a gene and it log2 ratio between the two conditions")
# Differential express genes at 10% treshold after ajst by multiple test by procedur of Benjamini-Hochberg are in red.
# MA plot

res_dif <- res_dif %>% mutate(sig=padj<0.05)
ggplot(res_dif, aes(x = baseMean, y = log2FoldChange, col = sig)) + 
  geom_point() + 
  scale_x_log10() +
  geom_hline(yintercept = 0, linetype = "dashed",color = "black") + 
  ggtitle("MA plot") + theme_bw()
```

```{r Volcano plot}
# Vulcano plot

ggplot(res_dif, aes(x=log2FoldChange, y=-log10(pvalue), col=sig)) +
  geom_point() +
  ggtitle("Volcano plot")
```

```{r PCA}
# PCA
vsdata <- vst(dds_5, blind=FALSE)
rld <- rlogTransformation(dds_5)
plotPCA(rld, intgroup="dex")
plotPCA(vsdata, intgroup="dex")
```

# Heatmap

```{r Heatmap}
# Heatmap





# Heatmap
res <- tbl_df(res)
res <- res %>% 
  arrange(padj) %>% 
  inner_join(anno,by=c("row"="ensgene")) %>%
  filter(padj<0.05)
NMF::aheatmap(assay(vsdata)[arrange(res, padj, pvalue)$row[1:50],], 
              labRow=arrange(res, padj, pvalue)$symbol[1:50], 
              scale="row", distfun="pearson", 
              annCol=dplyr::select(airway_metadata, dex, celltype), 
              col=c("green","black","black","red"))
dev.off()

```


### Rshiny application




